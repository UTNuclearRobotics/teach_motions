#!/usr/bin/env python

###################################################################
# Read the recorded velocity of robot arm(s) and send the commands.
###################################################################

###############################################################################
#      Title     : read_and_send
#      Project   : teach_motions
#      Created   : 4/26/2018
#      Author    : Andy Zelenak
#      Platforms : Ubuntu 64-bit
#      Copyright : Copyright The University of Texas at Austin, 2014-2017. All rights reserved.
#
#          All files within this directory are subject to the following, unless an alternative
#          license is explicitly included within the text of each file.
#
#          This software and documentation constitute an unpublished work
#          and contain valuable trade secrets and proprietary information
#          belonging to the University. None of the foregoing material may be
#          copied or duplicated or disclosed without the express, written
#          permission of the University. THE UNIVERSITY EXPRESSLY DISCLAIMS ANY
#          AND ALL WARRANTIES CONCERNING THIS SOFTWARE AND DOCUMENTATION,
#          INCLUDING ANY WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
#          PARTICULAR PURPOSE, AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY
#          THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF TRADE.
#          NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF
#          THE SOFTWARE OR DOCUMENTATION. Under no circumstances shall the
#          University be liable for incidental, special, indirect, direct or
#          consequential damages or loss of profits, interruption of business,
#          or related expenses which may arise from use of software or documentation,
#          including but not limited to those resulting from defects in software
#          and/or documentation, or loss or inaccuracy of data of any kind.
#
###############################################################################



# Read the recorded x/y/z/roll/pitch/yaw velocity and timestamps

# Publish the commands to the arm jogger:
#   Read the jogging parameters for each arm.
#   Publish with the right timestep.

from geometry_msgs.msg import TwistStamped

import csv
import moveit_commander
import rospkg
import rospy
import tf.transformations


class send_motions:

  def __init__(self):
    self.movegroup_names = []
    self.jog_cmd_topics = []
    self.ee_frame_names = []

    # Store incoming data in these variables
    self.times = []
    self.x_dot = []
    self.y_dot = []
    self.z_dot = []
    self.roll_dot = []
    self.pitch_dot = []
    self.yaw_dot = []
    self.ini_pose = []

    #######
    # Do it
    #######
    self.get_parameters()
    self.load_data()
    self.pub_cmds()


  def get_parameters(self):
    self.num_arms = rospy.get_param("teach_motions/num_arms")

    # Prompt user for the filename
    self.datafile_name = raw_input("Enter the datafile name, e.g. 'handle7': ")

    for arm_index in range( 0, int(self.num_arms) ):
      param_string = "teach_motions/ee" + str(arm_index) + "/movegroup_name"
      self.movegroup_names.append( rospy.get_param(param_string) )

      param_string = "teach_motions/ee" + str(arm_index) + "/jog_cmd_topic"
      self.jog_cmd_topics.append( rospy.get_param(param_string) )

      param_string = "teach_motions/ee" + str(arm_index) + "/ee_frame_name"
      self.ee_frame_names.append( rospy.get_param(param_string) )

    rospy.loginfo("These are the movegroups: ")
    rospy.loginfo(self.movegroup_names)

    rospy.loginfo("These are the jog_cmd_topics: ")
    rospy.loginfo(self.jog_cmd_topics)

    rospy.loginfo("These are the end-effector frame names: ")
    rospy.loginfo(self.ee_frame_names)


  def load_data(self):
    filepath = rospkg.RosPack().get_path('teach_motions')

    # Read columns of data for each arm, then combine them
    for arm_index in range( 0, int(self.num_arms) ):
      with open(filepath + '/data/' + self.datafile_name + '_arm' + str(arm_index) + '_processed.csv', 'r') as csvfile:
        reader = csv.reader(csvfile)
        data = list(reader)

        # Reject column headers
        data.pop(0)

        # Retrieve the rest of the data
        # (for example) Time history for arm0 is at self.times[0]
        # First time sample for arm0 is at self.times[0][0]
        self.times.append([col[0] for col in data])
        self.x_dot.append([col[1] for col in data])
        self.y_dot.append([col[2] for col in data])
        self.z_dot.append([col[3] for col in data])
        self.roll_dot.append([col[4] for col in data])
        self.pitch_dot.append([col[5] for col in data])
        self.yaw_dot.append([col[6] for col in data])


  def pub_cmds(self):
    cmd_publishers = []
    groups = []
    for arm_index in range( 0, int(self.num_arms) ):
      cmd_pub = rospy.Publisher(self.jog_cmd_topics[arm_index], TwistStamped, queue_size=1)
      cmd_publishers.append(cmd_pub)

      # Get some useful data for later
      groups.append( moveit_commander.MoveGroupCommander(self.movegroup_names[arm_index]) )
      self.ini_pose.append( groups[arm_index].get_current_pose() )

    # Get the rate of new cmds
    # For now, we'll assume this is constant and the same for both arms
    rate = rospy.Rate( 1/ (float(self.times[0][1])-float(self.times[0][0])) )

    # For each datapt
    ts = TwistStamped()
    i = 0
    for i in range(0, len(self.x_dot[0] )) :

      for arm_index in range( 0, int(self.num_arms) ):
	    	# Fill in a TwistStamped msg from incoming data
      	ts.header.frame_id = self.ee_frame_names[arm_index]
      	ts.header.stamp = rospy.Time.now()
      	ts.twist.linear.x = float( self.x_dot[arm_index][i] )
      	ts.twist.linear.y = float( self.y_dot[arm_index][i] )
      	ts.twist.linear.z = float( self.z_dot[arm_index][i] )
      	ts.twist.angular.x = float( self.roll_dot[arm_index][i] )
      	ts.twist.angular.y = float( self.pitch_dot[arm_index][i] )
      	ts.twist.angular.z = float( self.yaw_dot[arm_index][i] )

      	# Publish it
        cmd_publishers[arm_index].publish(ts)

      rate.sleep()

    # Print some useful info
    for arm_index in range( 0, int(self.num_arms) ):
      ini_orient = tf.transformations.euler_from_quaternion([
        self.ini_pose[arm_index].pose.orientation.x,
        self.ini_pose[arm_index].pose.orientation.y,
        self.ini_pose[arm_index].pose.orientation.z,
        self.ini_pose[arm_index].pose.orientation.w
        ])

      final_pose = groups[arm_index].get_current_pose()
      final_orient = tf.transformations.euler_from_quaternion([
        final_pose.pose.orientation.x,
        final_pose.pose.orientation.y,
        final_pose.pose.orientation.z,
        final_pose.pose.orientation.w
        ])

      # Print useful info
      rospy.loginfo("--------------------------------------------------------")
      rospy.loginfo("Change in pose in " + final_pose.header.frame_id + ": ")
      rospy.loginfo("X: " + str( final_pose.pose.position.x - self.ini_pose[arm_index].pose.position.x ))
      rospy.loginfo("Y: " + str( final_pose.pose.position.y - self.ini_pose[arm_index].pose.position.y ))
      rospy.loginfo("Z: " + str( final_pose.pose.position.z - self.ini_pose[arm_index].pose.position.z ))
      rospy.loginfo("Roll: " + str( (final_orient[0] - ini_orient[0])*180/3.14159) + " deg" )
      rospy.loginfo("Pitch: " + str( (final_orient[1] - ini_orient[1])*180/3.14159) + " deg" )
      rospy.loginfo("Yaw: " + str( (final_orient[2] - ini_orient[2])*180/3.14159) + " deg" )
      rospy.loginfo("--------------------------------------------------------")

    

if __name__ == '__main__':
  rospy.init_node('read_and_send', anonymous=True)

  sender = send_motions()